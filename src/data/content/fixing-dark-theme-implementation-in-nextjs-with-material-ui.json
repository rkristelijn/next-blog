{"content":"# Fixing Dark Theme Implementation in Next.js with Material-UI\n\nWhen building a modern web application, dark theme support is no longer optional—it's expected. Users spend significant time on screens, and dark themes reduce eye strain and provide a better experience in low-light environments. However, implementing a proper dark theme in Next.js with Material-UI can be tricky, especially when dealing with hardcoded colors and theme switching.\n\nIn this post, I'll walk through the challenges we faced and the solutions we implemented to create a robust dark theme system for our Next.js blog.\n\n## The Problem: Broken Theme Switching\n\nOur initial implementation had several issues:\n\n1. **Theme toggle not working** - The sun/moon icon would change, but the actual theme wouldn't switch\n2. **Hardcoded colors** - Some text remained black even in dark mode\n3. **Code blocks with wrong colors** - Light backgrounds in dark mode made code unreadable\n4. **Footer inconsistency** - Hardcoded background colors that didn't adapt\n\n## Understanding the Root Cause\n\nThe main issue was that we were trying to use MUI v7's experimental CSS variables approach, but our setup wasn't compatible. The `Experimental_CssVarsProvider` was deprecated, and we needed a different approach.\n\n### The Wrong Approach (What We Started With)\n\n```typescript\n// ❌ This doesn't work properly with MUI v7\nimport { Experimental_CssVarsProvider as CssVarsProvider } from '@mui/material/styles';\n\nexport default function ThemeRegistry({ children }: { children: React.ReactNode }) {\n  return (\n    <CssVarsProvider theme={theme}>\n      <CssBaseline />\n      {children}\n    </CssVarsProvider>\n  );\n}\n```\n\n## The Solution: Custom Theme Context\n\nWe implemented a custom theme context that provides full control over theme switching and ensures all components use theme-aware colors.\n\n### 1. Creating the Theme Context\n\n```typescript\n// src/components/ThemeRegistry.tsx\nimport { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { ThemeProvider, createTheme } from '@mui/material/styles';\n\n// Theme context for managing theme state\nconst ThemeContext = createContext<{\n  mode: 'light' | 'dark';\n  toggleTheme: () => void;\n}>({\n  mode: 'light',\n  toggleTheme: () => {},\n});\n\nexport const useTheme = () => useContext(ThemeContext);\n```\n\n### 2. Theme Provider with Dynamic Theme Creation\n\n```typescript\nfunction ThemeProviderWrapper({ children }: { children: ReactNode }) {\n  const [mode, setMode] = useState<'light' | 'dark'>('light');\n\n  useEffect(() => {\n    // Load theme preference from localStorage\n    const savedMode = localStorage.getItem('theme-mode') as 'light' | 'dark';\n    if (savedMode && (savedMode === 'light' || savedMode === 'dark')) {\n      setMode(savedMode);\n    } else {\n      // Check system preference\n      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n      setMode(prefersDark ? 'dark' : 'light');\n    }\n  }, []);\n\n  const toggleTheme = () => {\n    const newMode = mode === 'light' ? 'dark' : 'light';\n    setMode(newMode);\n    localStorage.setItem('theme-mode', newMode);\n  };\n\n  // Create theme based on current mode\n  const theme = createTheme({\n    palette: {\n      mode,\n      primary: {\n        main: '#1976d2',\n        light: '#42a5f5',\n        dark: '#1565c0',\n        contrastText: '#ffffff',\n      },\n      secondary: {\n        main: '#dc004e',\n        light: '#ff5983',\n        dark: '#9a0036',\n        contrastText: '#ffffff',\n      },\n      background: {\n        default: mode === 'light' ? '#fafafa' : '#121212',\n        paper: mode === 'light' ? '#ffffff' : '#1e1e1e',\n      },\n      text: {\n        primary: mode === 'light' ? 'rgba(0, 0, 0, 0.87)' : '#ffffff',\n        secondary: mode === 'light' ? 'rgba(0, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.7)',\n      },\n    },\n    // ... typography and shape configurations\n  });\n\n  return (\n    <ThemeContext.Provider value={{ mode, toggleTheme }}>\n      <ThemeProvider theme={theme}>\n        <CssBaseline />\n        {children}\n      </ThemeProvider>\n    </ThemeContext.Provider>\n  );\n}\n```\n\n## Fixing Hardcoded Colors\n\n### The Problem: Footer Background\n\n```typescript\n// ❌ Hardcoded color that doesn't adapt\n<Box component=\"footer\" sx={{ bgcolor: 'grey.100', py: 4 }}>\n```\n\n### The Solution: Theme-Aware Colors\n\n```typescript\n// ✅ Theme-aware color that adapts\n<Box component=\"footer\" sx={{ bgcolor: 'background.paper', py: 4 }}>\n```\n\n### The Problem: Code Block Styling\n\n```typescript\n// ❌ Hardcoded light background\n'& code': {\n  backgroundColor: '#f5f5f5',\n  padding: '0.125rem 0.25rem',\n  borderRadius: '0.25rem',\n  fontFamily: 'monospace',\n  fontSize: '0.875rem'\n},\n'& pre': {\n  backgroundColor: '#f5f5f5',\n  padding: '1rem',\n  borderRadius: '0.5rem',\n  overflow: 'auto',\n  mb: 1.5\n}\n```\n\n### The Solution: Theme-Aware Code Blocks\n\n```typescript\n// ✅ Theme-aware code styling\n'& code': {\n  backgroundColor: 'action.hover',\n  color: 'text.primary',\n  padding: '0.125rem 0.25rem',\n  borderRadius: '0.25rem',\n  fontFamily: 'monospace',\n  fontSize: '0.875rem'\n},\n'& pre': {\n  backgroundColor: 'background.paper',\n  border: 1,\n  borderColor: 'divider',\n  padding: '1rem',\n  borderRadius: '0.5rem',\n  overflow: 'auto',\n  mb: 1.5,\n  '& code': {\n    backgroundColor: 'transparent',\n    padding: 0,\n    borderRadius: 0,\n    color: 'text.primary'\n  }\n}\n```\n\n## Updating the Theme Toggle\n\n### Before: Using useColorScheme (Not Working)\n\n```typescript\n// ❌ This wasn't working properly\nimport { useColorScheme } from '@mui/material';\n\nexport default function ThemeToggle() {\n  const { mode, setMode } = useColorScheme();\n  // ... complex logic that wasn't working\n}\n```\n\n### After: Using Custom Theme Context\n\n```typescript\n// ✅ Simple and reliable\nimport { useTheme } from './ThemeRegistry';\n\nexport default function ThemeToggle() {\n  const { mode, toggleTheme } = useTheme();\n\n  return (\n    <Tooltip title={`Switch to ${mode === 'light' ? 'dark' : 'light'} mode`}>\n      <IconButton onClick={toggleTheme} color=\"inherit\">\n        {mode === 'light' ? <DarkModeIcon /> : <LightModeIcon />}\n      </IconButton>\n    </Tooltip>\n  );\n}\n```\n\n## Key Principles for Theme Implementation\n\n### 1. Never Use Hardcoded Colors\n\nAlways use MUI's theme tokens instead of hardcoded colors:\n\n- ✅ `color: 'text.primary'` instead of `color: '#000000'`\n- ✅ `backgroundColor: 'background.paper'` instead of `backgroundColor: '#ffffff'`\n- ✅ `borderColor: 'divider'` instead of `borderColor: '#e0e0e0'`\n\n### 2. Use Semantic Color Names\n\nMUI provides semantic color names that automatically adapt:\n\n- `text.primary` - Main text color\n- `text.secondary` - Secondary text color\n- `background.default` - Page background\n- `background.paper` - Card/component background\n- `action.hover` - Hover state background\n- `divider` - Border/divider color\n\n### 3. Test Both Themes\n\nAlways test your components in both light and dark modes to ensure:\n\n- Proper contrast ratios\n- Readable text\n- Consistent visual hierarchy\n- No hardcoded colors\n\n## Benefits of Proper Theme Implementation\n\n### 1. Better User Experience\n\n- Reduces eye strain in low-light environments\n- Respects user preferences\n- Provides consistent visual experience\n\n### 2. Accessibility\n\n- Proper contrast ratios in both themes\n- Screen reader compatibility\n- WCAG compliance\n\n### 3. Maintainability\n\n- Centralized theme management\n- Easy to modify colors globally\n- Consistent design system\n\n## Common Pitfalls to Avoid\n\n### 1. Mixing Theme Approaches\n\nDon't mix different theme approaches in the same application. Stick to one method consistently.\n\n### 2. Forgetting localStorage\n\nAlways persist user theme preferences to localStorage for better UX.\n\n### 3. Ignoring System Preferences\n\nRespect the user's system theme preference as the default.\n\n### 4. Hardcoded Colors in Components\n\nNever use hardcoded colors in components. Always use theme tokens.\n\n## Testing Your Theme Implementation\n\n### Manual Testing Checklist\n\n- [ ] Theme toggle works correctly\n- [ ] All text is readable in both themes\n- [ ] Code blocks have proper contrast\n- [ ] Buttons and interactive elements are visible\n- [ ] Theme preference persists on page reload\n- [ ] System preference is respected on first visit\n\n### Automated Testing\n\nConsider adding theme tests to your test suite:\n\n```typescript\ntest('theme toggle changes mode', () => {\n  render(<ThemeToggle />);\n  const toggle = screen.getByRole('button');\n  fireEvent.click(toggle);\n  expect(localStorage.getItem('theme-mode')).toBe('dark');\n});\n```\n\n## Conclusion\n\nImplementing a proper dark theme in Next.js with Material-UI requires careful attention to detail and avoiding common pitfalls. By using a custom theme context, theme-aware colors, and proper testing, we created a robust theme system that provides an excellent user experience.\n\nThe key takeaways are:\n\n1. **Use theme tokens instead of hardcoded colors**\n2. **Implement proper theme persistence**\n3. **Test thoroughly in both themes**\n4. **Respect user preferences**\n5. **Keep the implementation simple and maintainable**\n\nWith these principles in place, your application will provide a consistent and accessible experience across all themes and user preferences.\n\n## Next Steps\n\nNow that we have a solid theme foundation, we could enhance it further with:\n\n- **Theme-specific typography** - Different font weights or sizes for each theme\n- **Custom color palettes** - Brand-specific colors that work in both themes\n- **Animation transitions** - Smooth theme switching animations\n- **Advanced theming** - Multiple theme variants beyond just light/dark\n\nThe foundation we've built makes these enhancements much easier to implement in the future."}